"use strict";(globalThis.webpackChunkopenscan=globalThis.webpackChunkopenscan||[]).push([[2808],{1177:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArbitrumAdapter: () => (/* binding */ ArbitrumAdapter)\n/* harmony export */ });\n/* harmony import */ var _NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../NetworkAdapter */ 65413);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 59757);\n/* harmony import */ var _shared_extractData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/extractData */ 7891);\n/* harmony import */ var _shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/normalizeBlockNumber */ 72133);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n/**\n * Arbitrum blockchain adapter\n * Extends base NetworkAdapter with Arbitrum-specific features\n * Chain ID: 42161\n * Includes Arbitrum-specific trace methods (arbtrace_*)\n */\nvar ArbitrumAdapter = /** @class */ (function (_super) {\n    __extends(ArbitrumAdapter, _super);\n    function ArbitrumAdapter(networkId, client) {\n        var _this = _super.call(this, networkId) || this;\n        _this.client = client;\n        return _this;\n    }\n    ArbitrumAdapter.prototype.getBlock = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber)];\n                    case 1:\n                        result = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformArbitrumBlockToBlock)(blockData);\n                        return [2 /*return*/, {\n                                data: block,\n                                metadata: result.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getBlockWithTransactions = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block, transactionDetails, _i, _a, tx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber, true)];\n                    case 1:\n                        result = _b.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformArbitrumBlockToBlock)(blockData);\n                        transactionDetails = [];\n                        if (Array.isArray(blockData.transactions)) {\n                            for (_i = 0, _a = blockData.transactions; _i < _a.length; _i++) {\n                                tx = _a[_i];\n                                if (typeof tx !== "string") {\n                                    transactionDetails.push((0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformArbitrumTransactionToTransaction)(tx));\n                                }\n                            }\n                        }\n                        return [2 /*return*/, __assign(__assign({}, block), { transactionDetails: transactionDetails })];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getTransaction = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, txResult, receiptResult, txData, receiptData, transaction, blockResult, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getTransactionByHash(txHash),\n                            this.client.getTransactionReceipt(txHash),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), txResult = _a[0], receiptResult = _a[1];\n                        txData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txResult.data);\n                        if (!txData) {\n                            throw new Error("Transaction ".concat(txHash, " not found"));\n                        }\n                        receiptData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(receiptResult.data);\n                        transaction = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformArbitrumTransactionToTransaction)(txData, receiptData);\n                        if (!txData.blockNumber) return [3 /*break*/, 5];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlock(txData.blockNumber)];\n                    case 3:\n                        blockResult = _b.sent();\n                        if (blockResult.data) {\n                            transaction.timestamp = blockResult.data.timestamp;\n                            transaction.blockBaseFeePerGas = blockResult.data.baseFeePerGas;\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _b.sent();\n                        console.warn("Failed to fetch block for transaction timestamp:", error_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, {\n                            data: transaction,\n                            metadata: txResult.metadata,\n                        }];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, balanceResult, codeResult, txCountResult, balance, code, txCount, addressData;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getBalance(address, "latest"),\n                            this.client.getCode(address, "latest"),\n                            this.client.getTransactionCount(address, "latest"),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), balanceResult = _a[0], codeResult = _a[1], txCountResult = _a[2];\n                        balance = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(balanceResult.data) || "0x0";\n                        code = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(codeResult.data) || "0x";\n                        txCount = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txCountResult.data) || "0x0";\n                        addressData = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.createAddressFromBalance)(address, balance, code, txCount);\n                        return [2 /*return*/, {\n                                data: addressData,\n                                metadata: balanceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getAddressTransactions = function (_address_1, _fromBlock_1, _toBlock_1) {\n        return __awaiter(this, arguments, void 0, function (_address, _fromBlock, _toBlock, _limit) {\n            if (_limit === void 0) { _limit = 100; }\n            return __generator(this, function (_a) {\n                // Arbitrum doesn\'t have a native method to get transactions by address\n                // This would require scanning blocks or using an indexer\n                // For now, return empty result\n                console.warn("getAddressTransactions not fully implemented for Arbitrum");\n                return [2 /*return*/, {\n                        transactions: [],\n                        source: "none",\n                        isComplete: false,\n                        message: "Address transaction lookup not supported without indexer",\n                    }];\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getLatestBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.client.blockNumber()];\n                    case 1:\n                        result = _a.sent();\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data) || "0x0";\n                        return [2 /*return*/, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockNumber)];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getNetworkStats = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, gasPriceResult, syncingResult, blockNumberResult, versionResult, gasPrice, syncing, blockNumber, clientVersion, stats;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.gasPrice(),\n                            this.client.syncing(),\n                            this.client.blockNumber(),\n                            this.client.clientVersion(),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), gasPriceResult = _a[0], syncingResult = _a[1], blockNumberResult = _a[2], versionResult = _a[3];\n                        gasPrice = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(gasPriceResult.data) || "0x0";\n                        syncing = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(syncingResult.data);\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockNumberResult.data) || "0x0";\n                        clientVersion = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(versionResult.data) || "unknown";\n                        stats = {\n                            currentGasPrice: gasPrice,\n                            isSyncing: typeof syncing === "boolean" ? syncing : true,\n                            currentBlockNumber: blockNumber,\n                            clientVersion: clientVersion,\n                            metadata: {},\n                        };\n                        return [2 /*return*/, {\n                                data: stats,\n                                metadata: gasPriceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (count) {\n            var latestBlockNumber, blocks, promises, i, blockNum, results, _i, results_1, result;\n            if (count === void 0) { count = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        blocks = [];\n                        promises = [];\n                        for (i = 0; i < count; i++) {\n                            blockNum = latestBlockNumber - i;\n                            if (blockNum >= 0) {\n                                promises.push(this.getBlock(blockNum));\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        results = _a.sent();\n                        for (_i = 0, results_1 = results; _i < results_1.length; _i++) {\n                            result = results_1[_i];\n                            blocks.push(result.data);\n                        }\n                        return [2 /*return*/, blocks];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getTransactionsFromLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (blockCount) {\n            var latestBlockNumber;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        return [2 /*return*/, this.getTransactionsFromBlockRange(latestBlockNumber, blockCount)];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getTransactionsFromBlockRange = function (fromBlock_1) {\n        return __awaiter(this, arguments, void 0, function (fromBlock, blockCount) {\n            var transactions, i, blockNum, blockWithTxs, _i, _a, tx, error_2;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        transactions = [];\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < blockCount)) return [3 /*break*/, 6];\n                        blockNum = fromBlock - i;\n                        if (blockNum < 0)\n                            return [3 /*break*/, 6];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlockWithTransactions(blockNum)];\n                    case 3:\n                        blockWithTxs = _b.sent();\n                        for (_i = 0, _a = blockWithTxs.transactionDetails; _i < _a.length; _i++) {\n                            tx = _a[_i];\n                            transactions.push(__assign(__assign({}, tx), { blockNumber: blockWithTxs.number }));\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        console.error("Error fetching block ".concat(blockNum, ":"), error_2);\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/, transactions];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getChainId = function () {\n        return this.networkId;\n    };\n    ArbitrumAdapter.prototype.isTraceAvailable = function () {\n        return this.isLocalHost;\n    };\n    ArbitrumAdapter.prototype.getTransactionTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.debugTraceTransaction(txHash, {})];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_3 = _a.sent();\n                        console.error("Error getting transaction trace:", error_3);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // biome-ignore lint/suspicious/noExplicitAny: Generic trace result\n    ArbitrumAdapter.prototype.getCallTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.arbtraceTransaction(txHash)];\n                    case 2:\n                        result = _a.sent();\n                        // biome-ignore lint/suspicious/noExplicitAny: Generic trace result type\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_4 = _a.sent();\n                        console.error("Error getting call trace:", error_4);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ArbitrumAdapter.prototype.getBlockTrace = function (blockHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockResult, blockData, blockNumber, result, error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.client.getBlockByHash(blockHash, false)];\n                    case 2:\n                        blockResult = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockResult.data);\n                        if (!blockData)\n                            return [2 /*return*/, null];\n                        blockNumber = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockData.number);\n                        return [4 /*yield*/, this.client.arbtraceBlock((0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber))];\n                    case 3:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 4:\n                        error_5 = _a.sent();\n                        console.error("Error getting block trace:", error_5);\n                        return [2 /*return*/, null];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return ArbitrumAdapter;\n}(_NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__.NetworkAdapter));\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/ArbitrumAdapter/ArbitrumAdapter.ts?')},3131:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddressFromBalance: () => (/* binding */ createAddressFromBalance),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   transformRPCBlockToBlock: () => (/* binding */ transformRPCBlockToBlock),\n/* harmony export */   transformRPCTransactionToTransaction: () => (/* binding */ transformRPCTransactionToTransaction)\n/* harmony export */ });\n/**\n * Transforms an RPC block response into a Block domain object\n * Handles hex-to-decimal conversions and normalizes fields\n */\nfunction transformRPCBlockToBlock(rpcBlock) {\n    var timestamp = rpcBlock.timestamp\n        ? parseInt(rpcBlock.timestamp, rpcBlock.timestamp.startsWith("0x") ? 16 : 10).toString()\n        : "0";\n    return {\n        number: rpcBlock.number,\n        hash: rpcBlock.hash,\n        parentHash: rpcBlock.parentHash,\n        timestamp: timestamp,\n        baseFeePerGas: rpcBlock.baseFeePerGas ? BigInt(rpcBlock.baseFeePerGas).toString() : undefined,\n        nonce: rpcBlock.nonce,\n        difficulty: BigInt(rpcBlock.difficulty).toString(),\n        gasLimit: BigInt(rpcBlock.gasLimit).toString(),\n        gasUsed: BigInt(rpcBlock.gasUsed).toString(),\n        miner: rpcBlock.miner,\n        extraData: rpcBlock.extraData,\n        transactions: Array.isArray(rpcBlock.transactions)\n            ? rpcBlock.transactions.map(function (tx) { return (typeof tx === "string" ? tx : tx.hash); })\n            : [],\n        size: rpcBlock.size,\n        logsBloom: rpcBlock.logsBloom,\n        stateRoot: rpcBlock.stateRoot,\n        receiptsRoot: rpcBlock.receiptsRoot,\n        transactionsRoot: rpcBlock.transactionsRoot,\n        uncles: rpcBlock.uncles || [],\n        mixHash: rpcBlock.mixHash || "",\n        sha3Uncles: rpcBlock.sha3Uncles,\n        totalDifficulty: rpcBlock.totalDifficulty\n            ? BigInt(rpcBlock.totalDifficulty).toString()\n            : BigInt(rpcBlock.difficulty).toString(),\n        blobGasUsed: "",\n        excessBlobGas: "",\n        withdrawalsRoot: rpcBlock.withdrawalsRoot || "",\n        withdrawals: rpcBlock.withdrawals || [],\n    };\n}\n/**\n * Transforms an RPC transaction response into a Transaction domain object\n * Handles hex-to-decimal conversions and includes receipt if provided\n */\nfunction transformRPCTransactionToTransaction(rpcTx, receipt) {\n    var transaction = {\n        hash: rpcTx.hash,\n        from: rpcTx.from,\n        to: rpcTx.to || "",\n        value: BigInt(rpcTx.value).toString(),\n        gas: BigInt(rpcTx.gas).toString(),\n        gasPrice: rpcTx.gasPrice ? BigInt(rpcTx.gasPrice).toString() : "0",\n        maxFeePerGas: rpcTx.maxFeePerGas ? BigInt(rpcTx.maxFeePerGas).toString() : undefined,\n        maxPriorityFeePerGas: rpcTx.maxPriorityFeePerGas\n            ? BigInt(rpcTx.maxPriorityFeePerGas).toString()\n            : undefined,\n        nonce: rpcTx.nonce ? parseInt(rpcTx.nonce, 16).toString() : "0",\n        data: rpcTx.input,\n        blockNumber: rpcTx.blockNumber ? parseInt(rpcTx.blockNumber, 16).toString() : "0",\n        blockHash: rpcTx.blockHash || "",\n        transactionIndex: rpcTx.transactionIndex\n            ? parseInt(rpcTx.transactionIndex, 16).toString()\n            : "0",\n        v: rpcTx.v,\n        r: rpcTx.r,\n        s: rpcTx.s,\n        type: rpcTx.type,\n    };\n    if (receipt) {\n        transaction.receipt = {\n            blockHash: receipt.blockHash,\n            blockNumber: parseInt(receipt.blockNumber, 16).toString(),\n            contractAddress: receipt.contractAddress,\n            cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed).toString(),\n            effectiveGasPrice: receipt.effectiveGasPrice\n                ? BigInt(receipt.effectiveGasPrice).toString()\n                : "0",\n            from: receipt.from,\n            gasUsed: BigInt(receipt.gasUsed).toString(),\n            logs: receipt.logs,\n            logsBloom: receipt.logsBloom,\n            status: receipt.status || "0x1",\n            to: receipt.to || "",\n            transactionHash: receipt.transactionHash,\n            transactionIndex: parseInt(receipt.transactionIndex, 16).toString(),\n            type: receipt.type,\n        };\n    }\n    return transaction;\n}\n/**\n * Creates an Address domain object from balance, code, and transaction count\n */\nfunction createAddressFromBalance(address, balance, code, txCount) {\n    return {\n        address: address,\n        balance: BigInt(balance).toString(),\n        code: code,\n        txCount: parseInt(txCount, 16).toString(),\n        storageAt: {},\n    };\n}\n/**\n * Converts a hex string to a number\n */\nfunction hexToNumber(hex) {\n    return parseInt(hex, 16);\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/EVMAdapter/utils.ts?')},3440:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ 74848);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ 96540);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar Loader = react__WEBPACK_IMPORTED_MODULE_1___default().memo(function (_a) {\n    var _b = _a.size, size = _b === void 0 ? 40 : _b, _c = _a.color, color = _c === void 0 ? "#10b981" : _c, text = _a.text;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "loader-container", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "loader-spinner", style: {\n                    width: "".concat(size, "px"),\n                    height: "".concat(size, "px"),\n                    border: "3px solid rgba(16, 185, 129, 0.2)",\n                    borderTop: "3px solid ".concat(color),\n                } }), text && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { className: "loader-text", children: text })] }));\n});\nLoader.displayName = "Loader";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loader);\n\n\n//# sourceURL=webpack://openscan/./src/components/common/Loader.tsx?')},7891:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractData: () => (/* binding */ extractData)\n/* harmony export */ });\n/**\n * Extracts the actual data from a StrategyResult\n * Handles both fallback mode (data is T) and parallel mode (data is array of responses)\n *\n * In parallel mode, the current implementation of ParallelStrategy incorrectly returns\n * the array of provider responses as the data field. This helper extracts the first\n * successful response\'s data.\n */\n// biome-ignore lint/suspicious/noExplicitAny: Need to handle both T and provider response arrays\nfunction extractData(strategyResultData) {\n    var _a;\n    // Check if this looks like an array of provider responses (parallel mode bug)\n    if (Array.isArray(strategyResultData) && strategyResultData.length > 0) {\n        var firstItem = strategyResultData[0];\n        // Check if it has the RPCProviderResponse structure\n        if (firstItem &&\n            typeof firstItem === "object" &&\n            "url" in firstItem &&\n            "status" in firstItem &&\n            "data" in firstItem) {\n            // Find the first successful response\n            var successfulResponse = strategyResultData.find(\n            // biome-ignore lint/suspicious/noExplicitAny: Provider response type is dynamic\n            function (r) { return r.status === "success" && r.data !== undefined; });\n            return successfulResponse ? successfulResponse.data : (_a = strategyResultData[0]) === null || _a === void 0 ? void 0 : _a.data;\n        }\n    }\n    // Fallback mode or already extracted data\n    return strategyResultData;\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/shared/extractData.ts?')},16553:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolygonAdapter: () => (/* binding */ PolygonAdapter)\n/* harmony export */ });\n/* harmony import */ var _NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../NetworkAdapter */ 65413);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 97623);\n/* harmony import */ var _shared_extractData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/extractData */ 7891);\n/* harmony import */ var _shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/normalizeBlockNumber */ 72133);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n/**\n * Polygon blockchain service\n * Supports Polygon PoS (chain ID 137)\n */\nvar PolygonAdapter = /** @class */ (function (_super) {\n    __extends(PolygonAdapter, _super);\n    function PolygonAdapter(networkId, client) {\n        var _this = _super.call(this, networkId) || this;\n        _this.client = client;\n        return _this;\n    }\n    PolygonAdapter.prototype.getBlock = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber)];\n                    case 1:\n                        result = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformPolygonBlockToBlock)(blockData);\n                        return [2 /*return*/, {\n                                data: block,\n                                metadata: result.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getBlockWithTransactions = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block, transactionDetails, _i, _a, tx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber, true)];\n                    case 1:\n                        result = _b.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformPolygonBlockToBlock)(blockData);\n                        transactionDetails = [];\n                        if (Array.isArray(blockData.transactions)) {\n                            for (_i = 0, _a = blockData.transactions; _i < _a.length; _i++) {\n                                tx = _a[_i];\n                                if (typeof tx !== "string") {\n                                    transactionDetails.push((0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformPolygonTransactionToTransaction)(tx));\n                                }\n                            }\n                        }\n                        return [2 /*return*/, __assign(__assign({}, block), { transactionDetails: transactionDetails })];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getTransaction = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, txResult, receiptResult, txData, receiptData, transaction, blockResult, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getTransactionByHash(txHash),\n                            this.client.getTransactionReceipt(txHash),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), txResult = _a[0], receiptResult = _a[1];\n                        txData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txResult.data);\n                        if (!txData) {\n                            throw new Error("Transaction ".concat(txHash, " not found"));\n                        }\n                        receiptData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(receiptResult.data);\n                        transaction = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformPolygonTransactionToTransaction)(txData, receiptData);\n                        if (!txData.blockNumber) return [3 /*break*/, 5];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlock(txData.blockNumber)];\n                    case 3:\n                        blockResult = _b.sent();\n                        if (blockResult.data) {\n                            transaction.timestamp = blockResult.data.timestamp;\n                            transaction.blockBaseFeePerGas = blockResult.data.baseFeePerGas;\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _b.sent();\n                        console.warn("Failed to fetch block for transaction timestamp:", error_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, {\n                            data: transaction,\n                            metadata: txResult.metadata,\n                        }];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, balanceResult, codeResult, txCountResult, balance, code, txCount, addressData;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getBalance(address, "latest"),\n                            this.client.getCode(address, "latest"),\n                            this.client.getTransactionCount(address, "latest"),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), balanceResult = _a[0], codeResult = _a[1], txCountResult = _a[2];\n                        balance = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(balanceResult.data) || "0x0";\n                        code = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(codeResult.data) || "0x";\n                        txCount = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txCountResult.data) || "0x0";\n                        addressData = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.createAddressFromBalance)(address, balance, code, txCount);\n                        return [2 /*return*/, {\n                                data: addressData,\n                                metadata: balanceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getAddressTransactions = function (_address_1, _fromBlock_1, _toBlock_1) {\n        return __awaiter(this, arguments, void 0, function (_address, _fromBlock, _toBlock, _limit) {\n            if (_limit === void 0) { _limit = 100; }\n            return __generator(this, function (_a) {\n                // Polygon doesn\'t have a native method to get transactions by address\n                // This would require scanning blocks or using an indexer\n                // For now, return empty result\n                console.warn("getAddressTransactions not fully implemented for Polygon");\n                return [2 /*return*/, {\n                        transactions: [],\n                        source: "none",\n                        isComplete: false,\n                        message: "Address transaction lookup not supported without indexer",\n                    }];\n            });\n        });\n    };\n    PolygonAdapter.prototype.getLatestBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.client.blockNumber()];\n                    case 1:\n                        result = _a.sent();\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data) || "0x0";\n                        return [2 /*return*/, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockNumber)];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getNetworkStats = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, gasPriceResult, syncingResult, blockNumberResult, versionResult, gasPrice, syncing, blockNumber, clientVersion, stats;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.gasPrice(),\n                            this.client.syncing(),\n                            this.client.blockNumber(),\n                            this.client.clientVersion(),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), gasPriceResult = _a[0], syncingResult = _a[1], blockNumberResult = _a[2], versionResult = _a[3];\n                        gasPrice = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(gasPriceResult.data) || "0x0";\n                        syncing = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(syncingResult.data);\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockNumberResult.data) || "0x0";\n                        clientVersion = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(versionResult.data) || "unknown";\n                        stats = {\n                            currentGasPrice: gasPrice,\n                            isSyncing: typeof syncing === "boolean" ? syncing : true,\n                            currentBlockNumber: blockNumber,\n                            clientVersion: clientVersion,\n                            metadata: {},\n                        };\n                        return [2 /*return*/, {\n                                data: stats,\n                                metadata: gasPriceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (count) {\n            var latestBlockNumber, blocks, promises, i, blockNum, results, _i, results_1, result;\n            if (count === void 0) { count = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        blocks = [];\n                        promises = [];\n                        for (i = 0; i < count; i++) {\n                            blockNum = latestBlockNumber - i;\n                            if (blockNum >= 0) {\n                                promises.push(this.getBlock(blockNum));\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        results = _a.sent();\n                        for (_i = 0, results_1 = results; _i < results_1.length; _i++) {\n                            result = results_1[_i];\n                            blocks.push(result.data);\n                        }\n                        return [2 /*return*/, blocks];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getTransactionsFromLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (blockCount) {\n            var latestBlockNumber;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        return [2 /*return*/, this.getTransactionsFromBlockRange(latestBlockNumber, blockCount)];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getTransactionsFromBlockRange = function (fromBlock_1) {\n        return __awaiter(this, arguments, void 0, function (fromBlock, blockCount) {\n            var transactions, i, blockNum, blockWithTxs, _i, _a, tx, error_2;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        transactions = [];\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < blockCount)) return [3 /*break*/, 6];\n                        blockNum = fromBlock - i;\n                        if (blockNum < 0)\n                            return [3 /*break*/, 6];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlockWithTransactions(blockNum)];\n                    case 3:\n                        blockWithTxs = _b.sent();\n                        for (_i = 0, _a = blockWithTxs.transactionDetails; _i < _a.length; _i++) {\n                            tx = _a[_i];\n                            transactions.push(__assign(__assign({}, tx), { blockNumber: blockWithTxs.number }));\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        console.error("Error fetching block ".concat(blockNum, ":"), error_2);\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/, transactions];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getChainId = function () {\n        return this.networkId;\n    };\n    PolygonAdapter.prototype.isTraceAvailable = function () {\n        return this.isLocalHost;\n    };\n    PolygonAdapter.prototype.getTransactionTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.debugTraceTransaction(txHash, {})];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_3 = _a.sent();\n                        console.error("Error getting transaction trace:", error_3);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // biome-ignore lint/suspicious/noExplicitAny: Generic trace result\n    PolygonAdapter.prototype.getCallTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.traceTransaction(txHash)];\n                    case 2:\n                        result = _a.sent();\n                        // biome-ignore lint/suspicious/noExplicitAny: Generic trace result type\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_4 = _a.sent();\n                        console.error("Error getting call trace:", error_4);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PolygonAdapter.prototype.getBlockTrace = function (blockHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockResult, blockData, blockNumber, result, error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.client.getBlockByHash(blockHash, false)];\n                    case 2:\n                        blockResult = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockResult.data);\n                        if (!blockData)\n                            return [2 /*return*/, null];\n                        blockNumber = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockData.number);\n                        return [4 /*yield*/, this.client.traceBlock(blockNumber)];\n                    case 3:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 4:\n                        error_5 = _a.sent();\n                        console.error("Error getting block trace:", error_5);\n                        return [2 /*return*/, null];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return PolygonAdapter;\n}(_NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__.NetworkAdapter));\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/PolygonAdapter/PolygonAdapter.ts?')},25833:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BNBAdapter: () => (/* binding */ BNBAdapter)\n/* harmony export */ });\n/* harmony import */ var _NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../NetworkAdapter */ 65413);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 53847);\n/* harmony import */ var _shared_extractData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/extractData */ 7891);\n/* harmony import */ var _shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/normalizeBlockNumber */ 72133);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n/**\n * BNB Smart Chain (BSC) blockchain adapter\n * Extends base NetworkAdapter with standard EVM functionality\n * Chain ID: 56 (mainnet)\n */\nvar BNBAdapter = /** @class */ (function (_super) {\n    __extends(BNBAdapter, _super);\n    function BNBAdapter(networkId, client) {\n        var _this = _super.call(this, networkId) || this;\n        _this.client = client;\n        return _this;\n    }\n    BNBAdapter.prototype.getBlock = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber)];\n                    case 1:\n                        result = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBNBBlockToBlock)(blockData);\n                        return [2 /*return*/, {\n                                data: block,\n                                metadata: result.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getBlockWithTransactions = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block, transactionDetails, _i, _a, tx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber, true)];\n                    case 1:\n                        result = _b.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBNBBlockToBlock)(blockData);\n                        transactionDetails = [];\n                        if (Array.isArray(blockData.transactions)) {\n                            for (_i = 0, _a = blockData.transactions; _i < _a.length; _i++) {\n                                tx = _a[_i];\n                                if (typeof tx !== "string") {\n                                    transactionDetails.push((0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBNBTransactionToTransaction)(tx));\n                                }\n                            }\n                        }\n                        return [2 /*return*/, __assign(__assign({}, block), { transactionDetails: transactionDetails })];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getTransaction = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, txResult, receiptResult, txData, receiptData, transaction, blockResult, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getTransactionByHash(txHash),\n                            this.client.getTransactionReceipt(txHash),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), txResult = _a[0], receiptResult = _a[1];\n                        txData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txResult.data);\n                        if (!txData) {\n                            throw new Error("Transaction ".concat(txHash, " not found"));\n                        }\n                        receiptData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(receiptResult.data);\n                        transaction = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBNBTransactionToTransaction)(txData, receiptData);\n                        if (!txData.blockNumber) return [3 /*break*/, 5];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlock(txData.blockNumber)];\n                    case 3:\n                        blockResult = _b.sent();\n                        if (blockResult.data) {\n                            transaction.timestamp = blockResult.data.timestamp;\n                            transaction.blockBaseFeePerGas = blockResult.data.baseFeePerGas;\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _b.sent();\n                        console.warn("Failed to fetch block for transaction timestamp:", error_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, {\n                            data: transaction,\n                            metadata: txResult.metadata,\n                        }];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, balanceResult, codeResult, txCountResult, balance, code, txCount, addressData;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getBalance(address, "latest"),\n                            this.client.getCode(address, "latest"),\n                            this.client.getTransactionCount(address, "latest"),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), balanceResult = _a[0], codeResult = _a[1], txCountResult = _a[2];\n                        balance = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(balanceResult.data) || "0x0";\n                        code = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(codeResult.data) || "0x";\n                        txCount = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txCountResult.data) || "0x0";\n                        addressData = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.createAddressFromBalance)(address, balance, code, txCount);\n                        return [2 /*return*/, {\n                                data: addressData,\n                                metadata: balanceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getAddressTransactions = function (_address_1, _fromBlock_1, _toBlock_1) {\n        return __awaiter(this, arguments, void 0, function (_address, _fromBlock, _toBlock, _limit) {\n            if (_limit === void 0) { _limit = 100; }\n            return __generator(this, function (_a) {\n                // BNB doesn\'t have a native method to get transactions by address\n                // This would require scanning blocks or using an indexer\n                // For now, return empty result\n                console.warn("getAddressTransactions not fully implemented for BNB chain");\n                return [2 /*return*/, {\n                        transactions: [],\n                        source: "none",\n                        isComplete: false,\n                        message: "Address transaction lookup not supported without indexer",\n                    }];\n            });\n        });\n    };\n    BNBAdapter.prototype.getLatestBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.client.blockNumber()];\n                    case 1:\n                        result = _a.sent();\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data) || "0x0";\n                        return [2 /*return*/, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockNumber)];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getNetworkStats = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, gasPriceResult, syncingResult, blockNumberResult, versionResult, gasPrice, syncing, blockNumber, clientVersion, stats;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.gasPrice(),\n                            this.client.syncing(),\n                            this.client.blockNumber(),\n                            this.client.clientVersion(),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), gasPriceResult = _a[0], syncingResult = _a[1], blockNumberResult = _a[2], versionResult = _a[3];\n                        gasPrice = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(gasPriceResult.data) || "0x0";\n                        syncing = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(syncingResult.data);\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockNumberResult.data) || "0x0";\n                        clientVersion = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(versionResult.data) || "unknown";\n                        stats = {\n                            currentGasPrice: gasPrice,\n                            isSyncing: typeof syncing === "boolean" ? syncing : true,\n                            currentBlockNumber: blockNumber,\n                            clientVersion: clientVersion,\n                            metadata: {},\n                        };\n                        return [2 /*return*/, {\n                                data: stats,\n                                metadata: gasPriceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (count) {\n            var latestBlockNumber, blocks, promises, i, blockNum, results, _i, results_1, result;\n            if (count === void 0) { count = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        blocks = [];\n                        promises = [];\n                        for (i = 0; i < count; i++) {\n                            blockNum = latestBlockNumber - i;\n                            if (blockNum >= 0) {\n                                promises.push(this.getBlock(blockNum));\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        results = _a.sent();\n                        for (_i = 0, results_1 = results; _i < results_1.length; _i++) {\n                            result = results_1[_i];\n                            blocks.push(result.data);\n                        }\n                        return [2 /*return*/, blocks];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getTransactionsFromLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (blockCount) {\n            var latestBlockNumber;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        return [2 /*return*/, this.getTransactionsFromBlockRange(latestBlockNumber, blockCount)];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getTransactionsFromBlockRange = function (fromBlock_1) {\n        return __awaiter(this, arguments, void 0, function (fromBlock, blockCount) {\n            var transactions, i, blockNum, blockWithTxs, _i, _a, tx, error_2;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        transactions = [];\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < blockCount)) return [3 /*break*/, 6];\n                        blockNum = fromBlock - i;\n                        if (blockNum < 0)\n                            return [3 /*break*/, 6];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlockWithTransactions(blockNum)];\n                    case 3:\n                        blockWithTxs = _b.sent();\n                        for (_i = 0, _a = blockWithTxs.transactionDetails; _i < _a.length; _i++) {\n                            tx = _a[_i];\n                            transactions.push(__assign(__assign({}, tx), { blockNumber: blockWithTxs.number }));\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        console.error("Error fetching block ".concat(blockNum, ":"), error_2);\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/, transactions];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getChainId = function () {\n        return this.networkId;\n    };\n    BNBAdapter.prototype.isTraceAvailable = function () {\n        return this.isLocalHost;\n    };\n    BNBAdapter.prototype.getTransactionTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.debugTraceTransaction(txHash, {})];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_3 = _a.sent();\n                        console.error("Error getting transaction trace:", error_3);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // biome-ignore lint/suspicious/noExplicitAny: Generic trace result\n    BNBAdapter.prototype.getCallTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.traceTransaction(txHash)];\n                    case 2:\n                        result = _a.sent();\n                        // biome-ignore lint/suspicious/noExplicitAny: Generic trace result type\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_4 = _a.sent();\n                        console.error("Error getting call trace:", error_4);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BNBAdapter.prototype.getBlockTrace = function (blockHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockResult, blockData, blockNumber, result, error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.client.getBlockByHash(blockHash, false)];\n                    case 2:\n                        blockResult = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockResult.data);\n                        if (!blockData)\n                            return [2 /*return*/, null];\n                        blockNumber = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockData.number);\n                        return [4 /*yield*/, this.client.traceBlock(blockNumber)];\n                    case 3:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 4:\n                        error_5 = _a.sent();\n                        console.error("Error getting block trace:", error_5);\n                        return [2 /*return*/, null];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return BNBAdapter;\n}(_NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__.NetworkAdapter));\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/BNBAdapter/BNBAdapter.ts?')},26916:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdapterFactory: () => (/* binding */ AdapterFactory)\n/* harmony export */ });\n/* harmony import */ var _EVMAdapter_EVMAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EVMAdapter/EVMAdapter */ 31889);\n/* harmony import */ var _OptimismAdapter_OptimismAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OptimismAdapter/OptimismAdapter */ 42205);\n/* harmony import */ var _BaseAdapter_BaseAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseAdapter/BaseAdapter */ 46949);\n/* harmony import */ var _BNBAdapter_BNBAdapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BNBAdapter/BNBAdapter */ 25833);\n/* harmony import */ var _PolygonAdapter_PolygonAdapter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PolygonAdapter/PolygonAdapter */ 16553);\n/* harmony import */ var _ArbitrumAdapter_ArbitrumAdapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ArbitrumAdapter/ArbitrumAdapter */ 1177);\n\n\n\n\n\n\n// biome-ignore lint/complexity/noStaticOnlyClass: <TODO>\nvar AdapterFactory = /** @class */ (function () {\n    function AdapterFactory() {\n    }\n    AdapterFactory.createAdapter = function (networkId, client) {\n        switch (networkId) {\n            case 1:\n            case 11155111:\n            case 31337:\n                return new _EVMAdapter_EVMAdapter__WEBPACK_IMPORTED_MODULE_0__.EVMAdapter(networkId, client);\n            case 10:\n                return new _OptimismAdapter_OptimismAdapter__WEBPACK_IMPORTED_MODULE_1__.OptimismAdapter(networkId, client);\n            case 56:\n            case 97:\n                return new _BNBAdapter_BNBAdapter__WEBPACK_IMPORTED_MODULE_3__.BNBAdapter(networkId, client);\n            case 137:\n                return new _PolygonAdapter_PolygonAdapter__WEBPACK_IMPORTED_MODULE_4__.PolygonAdapter(networkId, client);\n            case 8453:\n                return new _BaseAdapter_BaseAdapter__WEBPACK_IMPORTED_MODULE_2__.BaseAdapter(networkId, client);\n            case 42161:\n                return new _ArbitrumAdapter_ArbitrumAdapter__WEBPACK_IMPORTED_MODULE_5__.ArbitrumAdapter(networkId, client);\n            default:\n                throw new Error("Unknown adapter for networkId: ".concat(networkId));\n        }\n    };\n    return AdapterFactory;\n}());\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/adaptersFactory.ts?')},31889:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EVMAdapter: () => (/* binding */ EVMAdapter)\n/* harmony export */ });\n/* harmony import */ var _NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../NetworkAdapter */ 65413);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 3131);\n/* harmony import */ var _shared_extractData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/extractData */ 7891);\n/* harmony import */ var _shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/normalizeBlockNumber */ 72133);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n/**\n * EVM-compatible blockchain service\n * Supports Ethereum, Arbitrum, Optimism, Base, BSC, Polygon\n */\nvar EVMAdapter = /** @class */ (function (_super) {\n    __extends(EVMAdapter, _super);\n    function EVMAdapter(networkId, client) {\n        var _this = _super.call(this, networkId) || this;\n        _this.client = client;\n        return _this;\n    }\n    EVMAdapter.prototype.getBlock = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber)];\n                    case 1:\n                        result = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformRPCBlockToBlock)(blockData);\n                        return [2 /*return*/, {\n                                data: block,\n                                metadata: result.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getBlockWithTransactions = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block, transactionDetails, _i, _a, tx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber, true)];\n                    case 1:\n                        result = _b.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformRPCBlockToBlock)(blockData);\n                        transactionDetails = [];\n                        if (Array.isArray(blockData.transactions)) {\n                            for (_i = 0, _a = blockData.transactions; _i < _a.length; _i++) {\n                                tx = _a[_i];\n                                if (typeof tx !== "string") {\n                                    transactionDetails.push((0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformRPCTransactionToTransaction)(tx));\n                                }\n                            }\n                        }\n                        return [2 /*return*/, __assign(__assign({}, block), { transactionDetails: transactionDetails })];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getTransaction = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, txResult, receiptResult, txData, receiptData, transaction, blockResult, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getTransactionByHash(txHash),\n                            this.client.getTransactionReceipt(txHash),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), txResult = _a[0], receiptResult = _a[1];\n                        txData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txResult.data);\n                        if (!txData) {\n                            throw new Error("Transaction ".concat(txHash, " not found"));\n                        }\n                        receiptData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(receiptResult.data);\n                        transaction = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformRPCTransactionToTransaction)(txData, receiptData);\n                        if (!txData.blockNumber) return [3 /*break*/, 5];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlock(txData.blockNumber)];\n                    case 3:\n                        blockResult = _b.sent();\n                        if (blockResult.data) {\n                            transaction.timestamp = blockResult.data.timestamp;\n                            transaction.blockBaseFeePerGas = blockResult.data.baseFeePerGas;\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _b.sent();\n                        console.warn("Failed to fetch block for transaction timestamp:", error_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, {\n                            data: transaction,\n                            metadata: txResult.metadata,\n                        }];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, balanceResult, codeResult, txCountResult, balance, code, txCount, addressData;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getBalance(address, "latest"),\n                            this.client.getCode(address, "latest"),\n                            this.client.getTransactionCount(address, "latest"),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), balanceResult = _a[0], codeResult = _a[1], txCountResult = _a[2];\n                        balance = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(balanceResult.data) || "0x0";\n                        code = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(codeResult.data) || "0x";\n                        txCount = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txCountResult.data) || "0x0";\n                        addressData = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.createAddressFromBalance)(address, balance, code, txCount);\n                        return [2 /*return*/, {\n                                data: addressData,\n                                metadata: balanceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getAddressTransactions = function (_address_1, _fromBlock_1, _toBlock_1) {\n        return __awaiter(this, arguments, void 0, function (_address, _fromBlock, _toBlock, _limit) {\n            if (_limit === void 0) { _limit = 100; }\n            return __generator(this, function (_a) {\n                // EVM doesn\'t have a native method to get transactions by address\n                // This would require scanning blocks or using an indexer\n                // For now, return empty result\n                console.warn("getAddressTransactions not fully implemented for EVM chains");\n                return [2 /*return*/, {\n                        transactions: [],\n                        source: "none",\n                        isComplete: false,\n                        message: "Address transaction lookup not supported without indexer",\n                    }];\n            });\n        });\n    };\n    EVMAdapter.prototype.getLatestBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.client.blockNumber()];\n                    case 1:\n                        result = _a.sent();\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data) || "0x0";\n                        return [2 /*return*/, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockNumber)];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getNetworkStats = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, gasPriceResult, syncingResult, blockNumberResult, versionResult, gasPrice, syncing, blockNumber, clientVersion, stats;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.gasPrice(),\n                            this.client.syncing(),\n                            this.client.blockNumber(),\n                            this.client.clientVersion(),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), gasPriceResult = _a[0], syncingResult = _a[1], blockNumberResult = _a[2], versionResult = _a[3];\n                        gasPrice = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(gasPriceResult.data) || "0x0";\n                        syncing = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(syncingResult.data);\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockNumberResult.data) || "0x0";\n                        clientVersion = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(versionResult.data) || "unknown";\n                        stats = {\n                            currentGasPrice: gasPrice,\n                            isSyncing: typeof syncing === "boolean" ? syncing : true,\n                            currentBlockNumber: blockNumber,\n                            clientVersion: clientVersion,\n                            metadata: {},\n                        };\n                        return [2 /*return*/, {\n                                data: stats,\n                                metadata: gasPriceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (count) {\n            var latestBlockNumber, blocks, promises, i, blockNum, results, _i, results_1, result;\n            if (count === void 0) { count = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        blocks = [];\n                        promises = [];\n                        for (i = 0; i < count; i++) {\n                            blockNum = latestBlockNumber - i;\n                            if (blockNum >= 0) {\n                                promises.push(this.getBlock(blockNum));\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        results = _a.sent();\n                        for (_i = 0, results_1 = results; _i < results_1.length; _i++) {\n                            result = results_1[_i];\n                            blocks.push(result.data);\n                        }\n                        return [2 /*return*/, blocks];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getTransactionsFromLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (blockCount) {\n            var latestBlockNumber;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        return [2 /*return*/, this.getTransactionsFromBlockRange(latestBlockNumber, blockCount)];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getTransactionsFromBlockRange = function (fromBlock_1) {\n        return __awaiter(this, arguments, void 0, function (fromBlock, blockCount) {\n            var transactions, i, blockNum, blockWithTxs, _i, _a, tx, error_2;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        transactions = [];\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < blockCount)) return [3 /*break*/, 6];\n                        blockNum = fromBlock - i;\n                        if (blockNum < 0)\n                            return [3 /*break*/, 6];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlockWithTransactions(blockNum)];\n                    case 3:\n                        blockWithTxs = _b.sent();\n                        for (_i = 0, _a = blockWithTxs.transactionDetails; _i < _a.length; _i++) {\n                            tx = _a[_i];\n                            transactions.push(__assign(__assign({}, tx), { blockNumber: blockWithTxs.number }));\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        console.error("Error fetching block ".concat(blockNum, ":"), error_2);\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/, transactions];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getChainId = function () {\n        return this.networkId;\n    };\n    EVMAdapter.prototype.isTraceAvailable = function () {\n        return this.isLocalHost;\n    };\n    EVMAdapter.prototype.getTransactionTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.debugTraceTransaction(txHash, {})];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_3 = _a.sent();\n                        console.error("Error getting transaction trace:", error_3);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // biome-ignore lint/suspicious/noExplicitAny: Generic trace result\n    EVMAdapter.prototype.getCallTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.traceTransaction(txHash)];\n                    case 2:\n                        result = _a.sent();\n                        // biome-ignore lint/suspicious/noExplicitAny: Generic trace result type\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_4 = _a.sent();\n                        console.error("Error getting call trace:", error_4);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    EVMAdapter.prototype.getBlockTrace = function (blockHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockResult, blockData, blockNumber, result, error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.client.getBlockByHash(blockHash, false)];\n                    case 2:\n                        blockResult = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockResult.data);\n                        if (!blockData)\n                            return [2 /*return*/, null];\n                        blockNumber = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockData.number);\n                        return [4 /*yield*/, this.client.traceBlock(blockNumber)];\n                    case 3:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 4:\n                        error_5 = _a.sent();\n                        console.error("Error getting block trace:", error_5);\n                        return [2 /*return*/, null];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return EVMAdapter;\n}(_NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__.NetworkAdapter));\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/EVMAdapter/EVMAdapter.ts?')},39444:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddressFromBalance: () => (/* binding */ createAddressFromBalance),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   transformBaseBlockToBlock: () => (/* binding */ transformBaseBlockToBlock),\n/* harmony export */   transformBaseTransactionToTransaction: () => (/* binding */ transformBaseTransactionToTransaction)\n/* harmony export */ });\n/**\n * Transforms a Base RPC block response into a Block domain object\n * Handles hex-to-decimal conversions and normalizes fields\n */\nfunction transformBaseBlockToBlock(rpcBlock) {\n    var timestamp = rpcBlock.timestamp\n        ? parseInt(rpcBlock.timestamp, rpcBlock.timestamp.startsWith("0x") ? 16 : 10).toString()\n        : "0";\n    return {\n        number: rpcBlock.number,\n        hash: rpcBlock.hash,\n        parentHash: rpcBlock.parentHash,\n        timestamp: timestamp,\n        baseFeePerGas: rpcBlock.baseFeePerGas ? BigInt(rpcBlock.baseFeePerGas).toString() : undefined,\n        nonce: rpcBlock.nonce,\n        difficulty: BigInt(rpcBlock.difficulty).toString(),\n        gasLimit: BigInt(rpcBlock.gasLimit).toString(),\n        gasUsed: BigInt(rpcBlock.gasUsed).toString(),\n        miner: rpcBlock.miner,\n        extraData: rpcBlock.extraData,\n        transactions: Array.isArray(rpcBlock.transactions)\n            ? rpcBlock.transactions.map(function (tx) {\n                return typeof tx === "string" ? tx : tx.hash;\n            })\n            : [],\n        size: rpcBlock.size,\n        logsBloom: rpcBlock.logsBloom,\n        stateRoot: rpcBlock.stateRoot,\n        receiptsRoot: rpcBlock.receiptsRoot,\n        transactionsRoot: rpcBlock.transactionsRoot,\n        uncles: rpcBlock.uncles || [],\n        mixHash: rpcBlock.mixHash || "",\n        sha3Uncles: rpcBlock.sha3Uncles,\n        totalDifficulty: rpcBlock.totalDifficulty\n            ? BigInt(rpcBlock.totalDifficulty).toString()\n            : BigInt(rpcBlock.difficulty).toString(),\n        blobGasUsed: "",\n        excessBlobGas: "",\n        withdrawalsRoot: rpcBlock.withdrawalsRoot || "",\n        withdrawals: rpcBlock.withdrawals\n            ? rpcBlock.withdrawals.map(function (w) { return ({\n                address: w.address,\n                amount: w.amount,\n                index: w.index,\n                validatorIndex: w.validatorIndex,\n            }); })\n            : [],\n    };\n}\n/**\n * Transforms a Base RPC transaction response into a Transaction domain object\n * Includes Base-specific L1 fee fields in the receipt (OP Stack compatible)\n */\nfunction transformBaseTransactionToTransaction(rpcTx, receipt) {\n    var transaction = {\n        hash: rpcTx.hash,\n        from: rpcTx.from,\n        to: rpcTx.to || "",\n        value: BigInt(rpcTx.value).toString(),\n        gas: BigInt(rpcTx.gas).toString(),\n        gasPrice: rpcTx.gasPrice ? BigInt(rpcTx.gasPrice).toString() : "0",\n        maxFeePerGas: rpcTx.maxFeePerGas ? BigInt(rpcTx.maxFeePerGas).toString() : undefined,\n        maxPriorityFeePerGas: rpcTx.maxPriorityFeePerGas\n            ? BigInt(rpcTx.maxPriorityFeePerGas).toString()\n            : undefined,\n        nonce: rpcTx.nonce ? parseInt(rpcTx.nonce, 16).toString() : "0",\n        data: rpcTx.input,\n        blockNumber: rpcTx.blockNumber ? parseInt(rpcTx.blockNumber, 16).toString() : "0",\n        blockHash: rpcTx.blockHash || "",\n        transactionIndex: rpcTx.transactionIndex\n            ? parseInt(rpcTx.transactionIndex, 16).toString()\n            : "0",\n        v: rpcTx.v,\n        r: rpcTx.r,\n        s: rpcTx.s,\n        type: rpcTx.type,\n    };\n    if (receipt) {\n        var baseReceipt = {\n            blockHash: receipt.blockHash,\n            blockNumber: parseInt(receipt.blockNumber, 16).toString(),\n            contractAddress: receipt.contractAddress,\n            cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed).toString(),\n            effectiveGasPrice: receipt.effectiveGasPrice\n                ? BigInt(receipt.effectiveGasPrice).toString()\n                : "0",\n            from: receipt.from,\n            gasUsed: BigInt(receipt.gasUsed).toString(),\n            logs: receipt.logs,\n            logsBloom: receipt.logsBloom,\n            status: receipt.status || "0x1",\n            to: receipt.to || "",\n            transactionHash: receipt.transactionHash,\n            transactionIndex: parseInt(receipt.transactionIndex, 16).toString(),\n            type: receipt.type,\n            // Base-specific L1 fee fields (OP Stack compatible)\n            l1Fee: receipt.l1Fee || "0",\n            l1GasPrice: receipt.l1GasPrice || "0",\n            l1GasUsed: receipt.l1GasUsed || "0",\n            l1FeeScalar: "1",\n        };\n        transaction.receipt = baseReceipt;\n    }\n    return transaction;\n}\n/**\n * Creates an Address domain object from balance, code, and transaction count\n */\nfunction createAddressFromBalance(address, balance, code, txCount) {\n    return {\n        address: address,\n        balance: BigInt(balance).toString(),\n        code: code,\n        txCount: parseInt(txCount, 16).toString(),\n        storageAt: {},\n    };\n}\n/**\n * Converts a hex string to a number\n */\nfunction hexToNumber(hex) {\n    return parseInt(hex, 16);\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/BaseAdapter/utils.ts?')},42205:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OptimismAdapter: () => (/* binding */ OptimismAdapter)\n/* harmony export */ });\n/* harmony import */ var _NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../NetworkAdapter */ 65413);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 70977);\n/* harmony import */ var _shared_extractData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/extractData */ 7891);\n/* harmony import */ var _shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/normalizeBlockNumber */ 72133);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n/**\n * Optimism (OP Stack) blockchain adapter\n * Extends base NetworkAdapter with Optimism-specific L1 fee handling\n * Chain ID: 10\n */\nvar OptimismAdapter = /** @class */ (function (_super) {\n    __extends(OptimismAdapter, _super);\n    function OptimismAdapter(networkId, client) {\n        var _this = _super.call(this, networkId) || this;\n        _this.client = client;\n        return _this;\n    }\n    OptimismAdapter.prototype.getBlock = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber)];\n                    case 1:\n                        result = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformOptimismBlockToBlock)(blockData);\n                        return [2 /*return*/, {\n                                data: block,\n                                metadata: result.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getBlockWithTransactions = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block, transactionDetails, _i, _a, tx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber, true)];\n                    case 1:\n                        result = _b.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformOptimismBlockToBlock)(blockData);\n                        transactionDetails = [];\n                        if (Array.isArray(blockData.transactions)) {\n                            for (_i = 0, _a = blockData.transactions; _i < _a.length; _i++) {\n                                tx = _a[_i];\n                                if (typeof tx !== "string") {\n                                    transactionDetails.push((0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformOptimismTransactionToTransaction)(tx));\n                                }\n                            }\n                        }\n                        return [2 /*return*/, __assign(__assign({}, block), { transactionDetails: transactionDetails })];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getTransaction = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, txResult, receiptResult, txData, receiptData, transaction, blockResult, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getTransactionByHash(txHash),\n                            this.client.getTransactionReceipt(txHash),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), txResult = _a[0], receiptResult = _a[1];\n                        txData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txResult.data);\n                        if (!txData) {\n                            throw new Error("Transaction ".concat(txHash, " not found"));\n                        }\n                        receiptData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(receiptResult.data);\n                        transaction = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformOptimismTransactionToTransaction)(txData, receiptData);\n                        if (!txData.blockNumber) return [3 /*break*/, 5];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlock(txData.blockNumber)];\n                    case 3:\n                        blockResult = _b.sent();\n                        if (blockResult.data) {\n                            transaction.timestamp = blockResult.data.timestamp;\n                            transaction.blockBaseFeePerGas = blockResult.data.baseFeePerGas;\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _b.sent();\n                        console.warn("Failed to fetch block for transaction timestamp:", error_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, {\n                            data: transaction,\n                            metadata: txResult.metadata,\n                        }];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, balanceResult, codeResult, txCountResult, balance, code, txCount, addressData;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getBalance(address, "latest"),\n                            this.client.getCode(address, "latest"),\n                            this.client.getTransactionCount(address, "latest"),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), balanceResult = _a[0], codeResult = _a[1], txCountResult = _a[2];\n                        balance = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(balanceResult.data) || "0x0";\n                        code = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(codeResult.data) || "0x";\n                        txCount = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txCountResult.data) || "0x0";\n                        addressData = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.createAddressFromBalance)(address, balance, code, txCount);\n                        return [2 /*return*/, {\n                                data: addressData,\n                                metadata: balanceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getAddressTransactions = function (_address_1, _fromBlock_1, _toBlock_1) {\n        return __awaiter(this, arguments, void 0, function (_address, _fromBlock, _toBlock, _limit) {\n            if (_limit === void 0) { _limit = 100; }\n            return __generator(this, function (_a) {\n                // Optimism doesn\'t have a native method to get transactions by address\n                // This would require scanning blocks or using an indexer\n                // For now, return empty result\n                console.warn("getAddressTransactions not fully implemented for Optimism");\n                return [2 /*return*/, {\n                        transactions: [],\n                        source: "none",\n                        isComplete: false,\n                        message: "Address transaction lookup not supported without indexer",\n                    }];\n            });\n        });\n    };\n    OptimismAdapter.prototype.getLatestBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.client.blockNumber()];\n                    case 1:\n                        result = _a.sent();\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data) || "0x0";\n                        return [2 /*return*/, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockNumber)];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getNetworkStats = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, gasPriceResult, syncingResult, blockNumberResult, versionResult, gasPrice, syncing, blockNumber, clientVersion, stats;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.gasPrice(),\n                            this.client.syncing(),\n                            this.client.blockNumber(),\n                            this.client.clientVersion(),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), gasPriceResult = _a[0], syncingResult = _a[1], blockNumberResult = _a[2], versionResult = _a[3];\n                        gasPrice = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(gasPriceResult.data) || "0x0";\n                        syncing = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(syncingResult.data);\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockNumberResult.data) || "0x0";\n                        clientVersion = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(versionResult.data) || "unknown";\n                        stats = {\n                            currentGasPrice: gasPrice,\n                            isSyncing: typeof syncing === "boolean" ? syncing : true,\n                            currentBlockNumber: blockNumber,\n                            clientVersion: clientVersion,\n                            metadata: {},\n                        };\n                        return [2 /*return*/, {\n                                data: stats,\n                                metadata: gasPriceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (count) {\n            var latestBlockNumber, blocks, promises, i, blockNum, results, _i, results_1, result;\n            if (count === void 0) { count = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        blocks = [];\n                        promises = [];\n                        for (i = 0; i < count; i++) {\n                            blockNum = latestBlockNumber - i;\n                            if (blockNum >= 0) {\n                                promises.push(this.getBlock(blockNum));\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        results = _a.sent();\n                        for (_i = 0, results_1 = results; _i < results_1.length; _i++) {\n                            result = results_1[_i];\n                            blocks.push(result.data);\n                        }\n                        return [2 /*return*/, blocks];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getTransactionsFromLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (blockCount) {\n            var latestBlockNumber;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        return [2 /*return*/, this.getTransactionsFromBlockRange(latestBlockNumber, blockCount)];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getTransactionsFromBlockRange = function (fromBlock_1) {\n        return __awaiter(this, arguments, void 0, function (fromBlock, blockCount) {\n            var transactions, i, blockNum, blockWithTxs, _i, _a, tx, error_2;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        transactions = [];\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < blockCount)) return [3 /*break*/, 6];\n                        blockNum = fromBlock - i;\n                        if (blockNum < 0)\n                            return [3 /*break*/, 6];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlockWithTransactions(blockNum)];\n                    case 3:\n                        blockWithTxs = _b.sent();\n                        for (_i = 0, _a = blockWithTxs.transactionDetails; _i < _a.length; _i++) {\n                            tx = _a[_i];\n                            transactions.push(__assign(__assign({}, tx), { blockNumber: blockWithTxs.number }));\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        console.error("Error fetching block ".concat(blockNum, ":"), error_2);\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/, transactions];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getChainId = function () {\n        return this.networkId;\n    };\n    OptimismAdapter.prototype.isTraceAvailable = function () {\n        return this.isLocalHost;\n    };\n    OptimismAdapter.prototype.getTransactionTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.debugTraceTransaction(txHash, {})];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_3 = _a.sent();\n                        console.error("Error getting transaction trace:", error_3);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // biome-ignore lint/suspicious/noExplicitAny: Generic trace result\n    OptimismAdapter.prototype.getCallTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.traceTransaction(txHash)];\n                    case 2:\n                        result = _a.sent();\n                        // biome-ignore lint/suspicious/noExplicitAny: Generic trace result type\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_4 = _a.sent();\n                        console.error("Error getting call trace:", error_4);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    OptimismAdapter.prototype.getBlockTrace = function (blockHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockResult, blockData, blockNumber, result, error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.client.getBlockByHash(blockHash, false)];\n                    case 2:\n                        blockResult = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockResult.data);\n                        if (!blockData)\n                            return [2 /*return*/, null];\n                        blockNumber = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockData.number);\n                        return [4 /*yield*/, this.client.traceBlock(blockNumber)];\n                    case 3:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 4:\n                        error_5 = _a.sent();\n                        console.error("Error getting block trace:", error_5);\n                        return [2 /*return*/, null];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return OptimismAdapter;\n}(_NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__.NetworkAdapter));\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/OptimismAdapter/OptimismAdapter.ts?')},46949:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseAdapter: () => (/* binding */ BaseAdapter)\n/* harmony export */ });\n/* harmony import */ var _NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../NetworkAdapter */ 65413);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ 39444);\n/* harmony import */ var _shared_extractData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/extractData */ 7891);\n/* harmony import */ var _shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/normalizeBlockNumber */ 72133);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== "function" && b !== null)\n            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n/**\n * Base blockchain adapter\n * Extends base NetworkAdapter with Base-specific L1 fee handling (OP Stack)\n * Chain ID: 8453\n */\nvar BaseAdapter = /** @class */ (function (_super) {\n    __extends(BaseAdapter, _super);\n    function BaseAdapter(networkId, client) {\n        var _this = _super.call(this, networkId) || this;\n        _this.client = client;\n        return _this;\n    }\n    BaseAdapter.prototype.getBlock = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber)];\n                    case 1:\n                        result = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBaseBlockToBlock)(blockData);\n                        return [2 /*return*/, {\n                                data: block,\n                                metadata: result.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getBlockWithTransactions = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedBlockNumber, result, blockData, block, transactionDetails, _i, _a, tx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        normalizedBlockNumber = (0,_shared_normalizeBlockNumber__WEBPACK_IMPORTED_MODULE_3__.normalizeBlockNumber)(blockNumber);\n                        return [4 /*yield*/, this.client.getBlockByNumber(normalizedBlockNumber, true)];\n                    case 1:\n                        result = _b.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data);\n                        if (!blockData) {\n                            throw new Error("Block ".concat(blockNumber, " not found"));\n                        }\n                        block = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBaseBlockToBlock)(blockData);\n                        transactionDetails = [];\n                        if (Array.isArray(blockData.transactions)) {\n                            for (_i = 0, _a = blockData.transactions; _i < _a.length; _i++) {\n                                tx = _a[_i];\n                                if (typeof tx !== "string") {\n                                    transactionDetails.push((0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBaseTransactionToTransaction)(tx));\n                                }\n                            }\n                        }\n                        return [2 /*return*/, __assign(__assign({}, block), { transactionDetails: transactionDetails })];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getTransaction = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, txResult, receiptResult, txData, receiptData, transaction, blockResult, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getTransactionByHash(txHash),\n                            this.client.getTransactionReceipt(txHash),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), txResult = _a[0], receiptResult = _a[1];\n                        txData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txResult.data);\n                        if (!txData) {\n                            throw new Error("Transaction ".concat(txHash, " not found"));\n                        }\n                        receiptData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(receiptResult.data);\n                        transaction = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.transformBaseTransactionToTransaction)(txData, receiptData);\n                        if (!txData.blockNumber) return [3 /*break*/, 5];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlock(txData.blockNumber)];\n                    case 3:\n                        blockResult = _b.sent();\n                        if (blockResult.data) {\n                            transaction.timestamp = blockResult.data.timestamp;\n                            transaction.blockBaseFeePerGas = blockResult.data.baseFeePerGas;\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _b.sent();\n                        console.warn("Failed to fetch block for transaction timestamp:", error_1);\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, {\n                            data: transaction,\n                            metadata: txResult.metadata,\n                        }];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, balanceResult, codeResult, txCountResult, balance, code, txCount, addressData;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.getBalance(address, "latest"),\n                            this.client.getCode(address, "latest"),\n                            this.client.getTransactionCount(address, "latest"),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), balanceResult = _a[0], codeResult = _a[1], txCountResult = _a[2];\n                        balance = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(balanceResult.data) || "0x0";\n                        code = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(codeResult.data) || "0x";\n                        txCount = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(txCountResult.data) || "0x0";\n                        addressData = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.createAddressFromBalance)(address, balance, code, txCount);\n                        return [2 /*return*/, {\n                                data: addressData,\n                                metadata: balanceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getAddressTransactions = function (_address_1, _fromBlock_1, _toBlock_1) {\n        return __awaiter(this, arguments, void 0, function (_address, _fromBlock, _toBlock, _limit) {\n            if (_limit === void 0) { _limit = 100; }\n            return __generator(this, function (_a) {\n                // Base doesn\'t have a native method to get transactions by address\n                // This would require scanning blocks or using an indexer\n                // For now, return empty result\n                console.warn("getAddressTransactions not fully implemented for Base");\n                return [2 /*return*/, {\n                        transactions: [],\n                        source: "none",\n                        isComplete: false,\n                        message: "Address transaction lookup not supported without indexer",\n                    }];\n            });\n        });\n    };\n    BaseAdapter.prototype.getLatestBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.client.blockNumber()];\n                    case 1:\n                        result = _a.sent();\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data) || "0x0";\n                        return [2 /*return*/, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockNumber)];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getNetworkStats = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, gasPriceResult, syncingResult, blockNumberResult, versionResult, gasPrice, syncing, blockNumber, clientVersion, stats;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.client.gasPrice(),\n                            this.client.syncing(),\n                            this.client.blockNumber(),\n                            this.client.clientVersion(),\n                        ])];\n                    case 1:\n                        _a = _b.sent(), gasPriceResult = _a[0], syncingResult = _a[1], blockNumberResult = _a[2], versionResult = _a[3];\n                        gasPrice = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(gasPriceResult.data) || "0x0";\n                        syncing = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(syncingResult.data);\n                        blockNumber = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockNumberResult.data) || "0x0";\n                        clientVersion = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(versionResult.data) || "unknown";\n                        stats = {\n                            currentGasPrice: gasPrice,\n                            isSyncing: typeof syncing === "boolean" ? syncing : true,\n                            currentBlockNumber: blockNumber,\n                            clientVersion: clientVersion,\n                            metadata: {},\n                        };\n                        return [2 /*return*/, {\n                                data: stats,\n                                metadata: gasPriceResult.metadata,\n                            }];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (count) {\n            var latestBlockNumber, blocks, promises, i, blockNum, results, _i, results_1, result;\n            if (count === void 0) { count = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        blocks = [];\n                        promises = [];\n                        for (i = 0; i < count; i++) {\n                            blockNum = latestBlockNumber - i;\n                            if (blockNum >= 0) {\n                                promises.push(this.getBlock(blockNum));\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        results = _a.sent();\n                        for (_i = 0, results_1 = results; _i < results_1.length; _i++) {\n                            result = results_1[_i];\n                            blocks.push(result.data);\n                        }\n                        return [2 /*return*/, blocks];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getTransactionsFromLatestBlocks = function () {\n        return __awaiter(this, arguments, void 0, function (blockCount) {\n            var latestBlockNumber;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getLatestBlockNumber()];\n                    case 1:\n                        latestBlockNumber = _a.sent();\n                        return [2 /*return*/, this.getTransactionsFromBlockRange(latestBlockNumber, blockCount)];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getTransactionsFromBlockRange = function (fromBlock_1) {\n        return __awaiter(this, arguments, void 0, function (fromBlock, blockCount) {\n            var transactions, i, blockNum, blockWithTxs, _i, _a, tx, error_2;\n            if (blockCount === void 0) { blockCount = 10; }\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        transactions = [];\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < blockCount)) return [3 /*break*/, 6];\n                        blockNum = fromBlock - i;\n                        if (blockNum < 0)\n                            return [3 /*break*/, 6];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.getBlockWithTransactions(blockNum)];\n                    case 3:\n                        blockWithTxs = _b.sent();\n                        for (_i = 0, _a = blockWithTxs.transactionDetails; _i < _a.length; _i++) {\n                            tx = _a[_i];\n                            transactions.push(__assign(__assign({}, tx), { blockNumber: blockWithTxs.number }));\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        console.error("Error fetching block ".concat(blockNum, ":"), error_2);\n                        return [3 /*break*/, 5];\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/, transactions];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getChainId = function () {\n        return this.networkId;\n    };\n    BaseAdapter.prototype.isTraceAvailable = function () {\n        return this.isLocalHost;\n    };\n    BaseAdapter.prototype.getTransactionTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.debugTraceTransaction(txHash, {})];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_3 = _a.sent();\n                        console.error("Error getting transaction trace:", error_3);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // biome-ignore lint/suspicious/noExplicitAny: Generic trace result\n    BaseAdapter.prototype.getCallTrace = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.client.traceTransaction(txHash)];\n                    case 2:\n                        result = _a.sent();\n                        // biome-ignore lint/suspicious/noExplicitAny: Generic trace result type\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 3:\n                        error_4 = _a.sent();\n                        console.error("Error getting call trace:", error_4);\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseAdapter.prototype.getBlockTrace = function (blockHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockResult, blockData, blockNumber, result, error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isLocalHost) {\n                            console.warn("Trace methods are only available on localhost networks");\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, this.client.getBlockByHash(blockHash, false)];\n                    case 2:\n                        blockResult = _a.sent();\n                        blockData = (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(blockResult.data);\n                        if (!blockData)\n                            return [2 /*return*/, null];\n                        blockNumber = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(blockData.number);\n                        return [4 /*yield*/, this.client.traceBlock(blockNumber)];\n                    case 3:\n                        result = _a.sent();\n                        return [2 /*return*/, (0,_shared_extractData__WEBPACK_IMPORTED_MODULE_2__.extractData)(result.data)];\n                    case 4:\n                        error_5 = _a.sent();\n                        console.error("Error getting block trace:", error_5);\n                        return [2 /*return*/, null];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return BaseAdapter;\n}(_NetworkAdapter__WEBPACK_IMPORTED_MODULE_0__.NetworkAdapter));\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/BaseAdapter/BaseAdapter.ts?')},48198:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataService: () => (/* binding */ DataService)\n/* harmony export */ });\n/* harmony import */ var explorer_network_connectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! explorer-network-connectors */ 77544);\n/* harmony import */ var _adapters_adaptersFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/adaptersFactory */ 26916);\n/* harmony import */ var _config_rpcConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config/rpcConfig */ 37918);\n\n\n\nvar DataService = /** @class */ (function () {\n    function DataService(networkId, rpcUrlsMap, strategy) {\n        if (strategy === void 0) { strategy = "fallback"; }\n        var rpcUrls = (0,_config_rpcConfig__WEBPACK_IMPORTED_MODULE_2__.getRPCUrls)(networkId, rpcUrlsMap);\n        var networkClient = explorer_network_connectors__WEBPACK_IMPORTED_MODULE_0__.ClientFactory.createTypedClient(networkId, {\n            rpcUrls: rpcUrls,\n            type: strategy,\n        });\n        this.networkAdapter = _adapters_adaptersFactory__WEBPACK_IMPORTED_MODULE_1__.AdapterFactory.createAdapter(networkId, networkClient);\n    }\n    return DataService;\n}());\n\n\n\n//# sourceURL=webpack://openscan/./src/services/DataService.ts?')},53847:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddressFromBalance: () => (/* binding */ createAddressFromBalance),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   transformBNBBlockToBlock: () => (/* binding */ transformBNBBlockToBlock),\n/* harmony export */   transformBNBTransactionToTransaction: () => (/* binding */ transformBNBTransactionToTransaction)\n/* harmony export */ });\n/**\n * Transforms a BNB RPC block response into a Block domain object\n * Handles hex-to-decimal conversions and normalizes fields\n */\nfunction transformBNBBlockToBlock(rpcBlock) {\n    var timestamp = rpcBlock.timestamp\n        ? parseInt(rpcBlock.timestamp, rpcBlock.timestamp.startsWith("0x") ? 16 : 10).toString()\n        : "0";\n    return {\n        number: rpcBlock.number,\n        hash: rpcBlock.hash,\n        parentHash: rpcBlock.parentHash,\n        timestamp: timestamp,\n        baseFeePerGas: rpcBlock.baseFeePerGas ? BigInt(rpcBlock.baseFeePerGas).toString() : undefined,\n        nonce: rpcBlock.nonce,\n        difficulty: BigInt(rpcBlock.difficulty).toString(),\n        gasLimit: BigInt(rpcBlock.gasLimit).toString(),\n        gasUsed: BigInt(rpcBlock.gasUsed).toString(),\n        miner: rpcBlock.miner,\n        extraData: rpcBlock.extraData,\n        transactions: Array.isArray(rpcBlock.transactions)\n            ? rpcBlock.transactions.map(function (tx) {\n                return typeof tx === "string" ? tx : tx.hash;\n            })\n            : [],\n        size: rpcBlock.size,\n        logsBloom: rpcBlock.logsBloom,\n        stateRoot: rpcBlock.stateRoot,\n        receiptsRoot: rpcBlock.receiptsRoot,\n        transactionsRoot: rpcBlock.transactionsRoot,\n        uncles: rpcBlock.uncles || [],\n        mixHash: rpcBlock.mixHash || "",\n        sha3Uncles: rpcBlock.sha3Uncles,\n        totalDifficulty: rpcBlock.totalDifficulty\n            ? BigInt(rpcBlock.totalDifficulty).toString()\n            : BigInt(rpcBlock.difficulty).toString(),\n        blobGasUsed: "",\n        excessBlobGas: "",\n        withdrawalsRoot: rpcBlock.withdrawalsRoot || "",\n        withdrawals: rpcBlock.withdrawals\n            ? rpcBlock.withdrawals.map(function (w) { return ({\n                address: w.address,\n                amount: w.amount,\n                index: w.index,\n                validatorIndex: w.validatorIndex,\n            }); })\n            : [],\n    };\n}\n/**\n * Transforms a BNB RPC transaction response into a Transaction domain object\n * Handles hex-to-decimal conversions and includes receipt if provided\n */\nfunction transformBNBTransactionToTransaction(rpcTx, receipt) {\n    var transaction = {\n        hash: rpcTx.hash,\n        from: rpcTx.from,\n        to: rpcTx.to || "",\n        value: BigInt(rpcTx.value).toString(),\n        gas: BigInt(rpcTx.gas).toString(),\n        gasPrice: rpcTx.gasPrice ? BigInt(rpcTx.gasPrice).toString() : "0",\n        maxFeePerGas: rpcTx.maxFeePerGas ? BigInt(rpcTx.maxFeePerGas).toString() : undefined,\n        maxPriorityFeePerGas: rpcTx.maxPriorityFeePerGas\n            ? BigInt(rpcTx.maxPriorityFeePerGas).toString()\n            : undefined,\n        nonce: rpcTx.nonce ? parseInt(rpcTx.nonce, 16).toString() : "0",\n        data: rpcTx.input,\n        blockNumber: rpcTx.blockNumber ? parseInt(rpcTx.blockNumber, 16).toString() : "0",\n        blockHash: rpcTx.blockHash || "",\n        transactionIndex: rpcTx.transactionIndex\n            ? parseInt(rpcTx.transactionIndex, 16).toString()\n            : "0",\n        v: rpcTx.v,\n        r: rpcTx.r,\n        s: rpcTx.s,\n        type: rpcTx.type,\n    };\n    if (receipt) {\n        transaction.receipt = {\n            blockHash: receipt.blockHash,\n            blockNumber: parseInt(receipt.blockNumber, 16).toString(),\n            contractAddress: receipt.contractAddress,\n            cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed).toString(),\n            effectiveGasPrice: receipt.effectiveGasPrice\n                ? BigInt(receipt.effectiveGasPrice).toString()\n                : "0",\n            from: receipt.from,\n            gasUsed: BigInt(receipt.gasUsed).toString(),\n            logs: receipt.logs,\n            logsBloom: receipt.logsBloom,\n            status: receipt.status || "0x1",\n            to: receipt.to || "",\n            transactionHash: receipt.transactionHash,\n            transactionIndex: parseInt(receipt.transactionIndex, 16).toString(),\n            type: receipt.type,\n        };\n    }\n    return transaction;\n}\n/**\n * Creates an Address domain object from balance, code, and transaction count\n */\nfunction createAddressFromBalance(address, balance, code, txCount) {\n    return {\n        address: address,\n        balance: BigInt(balance).toString(),\n        code: code,\n        txCount: parseInt(txCount, 16).toString(),\n        storageAt: {},\n    };\n}\n/**\n * Converts a hex string to a number\n */\nfunction hexToNumber(hex) {\n    return parseInt(hex, 16);\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/BNBAdapter/utils.ts?')},59757:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddressFromBalance: () => (/* binding */ createAddressFromBalance),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   transformArbitrumBlockToBlock: () => (/* binding */ transformArbitrumBlockToBlock),\n/* harmony export */   transformArbitrumTransactionToTransaction: () => (/* binding */ transformArbitrumTransactionToTransaction)\n/* harmony export */ });\n/**\n * Transforms an Arbitrum RPC block response into a Block domain object\n * Handles hex-to-decimal conversions and normalizes fields\n * Includes Arbitrum-specific fields: l1BlockNumber, sendCount, sendRoot\n */\nfunction transformArbitrumBlockToBlock(rpcBlock) {\n    var timestamp = rpcBlock.timestamp\n        ? parseInt(rpcBlock.timestamp, rpcBlock.timestamp.startsWith("0x") ? 16 : 10).toString()\n        : "0";\n    return {\n        number: rpcBlock.number,\n        hash: rpcBlock.hash,\n        parentHash: rpcBlock.parentHash,\n        timestamp: timestamp,\n        baseFeePerGas: rpcBlock.baseFeePerGas ? BigInt(rpcBlock.baseFeePerGas).toString() : undefined,\n        nonce: rpcBlock.nonce,\n        difficulty: BigInt(rpcBlock.difficulty).toString(),\n        gasLimit: BigInt(rpcBlock.gasLimit).toString(),\n        gasUsed: BigInt(rpcBlock.gasUsed).toString(),\n        miner: rpcBlock.miner,\n        extraData: rpcBlock.extraData,\n        transactions: Array.isArray(rpcBlock.transactions)\n            ? rpcBlock.transactions.map(function (tx) {\n                return typeof tx === "string" ? tx : tx.hash;\n            })\n            : [],\n        size: rpcBlock.size,\n        logsBloom: rpcBlock.logsBloom,\n        stateRoot: rpcBlock.stateRoot,\n        receiptsRoot: rpcBlock.receiptsRoot,\n        transactionsRoot: rpcBlock.transactionsRoot,\n        uncles: rpcBlock.uncles || [],\n        mixHash: rpcBlock.mixHash || "",\n        sha3Uncles: rpcBlock.sha3Uncles,\n        totalDifficulty: BigInt(rpcBlock.difficulty).toString(),\n        blobGasUsed: "",\n        excessBlobGas: "",\n        withdrawalsRoot: "",\n        withdrawals: [],\n    };\n}\n/**\n * Transforms an Arbitrum RPC transaction response into a Transaction domain object\n * Includes Arbitrum-specific receipt fields: gasUsedForL1, l1BlockNumber\n */\nfunction transformArbitrumTransactionToTransaction(rpcTx, receipt) {\n    var transaction = {\n        hash: rpcTx.hash,\n        from: rpcTx.from,\n        to: rpcTx.to || "",\n        value: BigInt(rpcTx.value).toString(),\n        gas: BigInt(rpcTx.gas).toString(),\n        gasPrice: rpcTx.gasPrice ? BigInt(rpcTx.gasPrice).toString() : "0",\n        maxFeePerGas: undefined,\n        maxPriorityFeePerGas: undefined,\n        nonce: rpcTx.nonce ? parseInt(rpcTx.nonce, 16).toString() : "0",\n        data: rpcTx.input,\n        blockNumber: rpcTx.blockNumber ? parseInt(rpcTx.blockNumber, 16).toString() : "0",\n        blockHash: rpcTx.blockHash || "",\n        transactionIndex: rpcTx.transactionIndex\n            ? parseInt(rpcTx.transactionIndex, 16).toString()\n            : "0",\n        v: rpcTx.v,\n        r: rpcTx.r,\n        s: rpcTx.s,\n        type: rpcTx.type,\n    };\n    if (receipt) {\n        var arbitrumReceipt = {\n            blockHash: receipt.blockHash,\n            blockNumber: parseInt(receipt.blockNumber, 16).toString(),\n            contractAddress: receipt.contractAddress,\n            cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed).toString(),\n            effectiveGasPrice: receipt.effectiveGasPrice\n                ? BigInt(receipt.effectiveGasPrice).toString()\n                : "0",\n            from: receipt.from,\n            gasUsed: BigInt(receipt.gasUsed).toString(),\n            logs: receipt.logs,\n            logsBloom: receipt.logsBloom,\n            status: receipt.status || "0x1",\n            to: receipt.to || "",\n            transactionHash: receipt.transactionHash,\n            transactionIndex: parseInt(receipt.transactionIndex, 16).toString(),\n            type: receipt.type,\n        };\n        transaction.receipt = arbitrumReceipt;\n    }\n    return transaction;\n}\n/**\n * Creates an Address domain object from balance, code, and transaction count\n */\nfunction createAddressFromBalance(address, balance, code, txCount) {\n    return {\n        address: address,\n        balance: BigInt(balance).toString(),\n        code: code,\n        txCount: parseInt(txCount, 16).toString(),\n        storageAt: {},\n    };\n}\n/**\n * Converts a hex string to a number\n */\nfunction hexToNumber(hex) {\n    return parseInt(hex, 16);\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/ArbitrumAdapter/utils.ts?')},65413:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkAdapter: () => (/* binding */ NetworkAdapter)\n/* harmony export */ });\n/**\n * Base interface for blockchain-specific services\n * All chain implementations must conform to this unified API\n */\nvar NetworkAdapter = /** @class */ (function () {\n    function NetworkAdapter(networkId) {\n        this.networkId = networkId;\n        this.isLocalHost = networkId === 31337;\n    }\n    return NetworkAdapter;\n}());\n\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/NetworkAdapter.ts?")},70977:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddressFromBalance: () => (/* binding */ createAddressFromBalance),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   transformOptimismBlockToBlock: () => (/* binding */ transformOptimismBlockToBlock),\n/* harmony export */   transformOptimismTransactionToTransaction: () => (/* binding */ transformOptimismTransactionToTransaction)\n/* harmony export */ });\n/**\n * Transforms an Optimism RPC block response into a Block domain object\n * Handles hex-to-decimal conversions and normalizes fields\n */\nfunction transformOptimismBlockToBlock(rpcBlock) {\n    var timestamp = rpcBlock.timestamp\n        ? parseInt(rpcBlock.timestamp, rpcBlock.timestamp.startsWith("0x") ? 16 : 10).toString()\n        : "0";\n    return {\n        number: rpcBlock.number,\n        hash: rpcBlock.hash,\n        parentHash: rpcBlock.parentHash,\n        timestamp: timestamp,\n        baseFeePerGas: rpcBlock.baseFeePerGas ? BigInt(rpcBlock.baseFeePerGas).toString() : undefined,\n        nonce: rpcBlock.nonce,\n        difficulty: BigInt(rpcBlock.difficulty).toString(),\n        gasLimit: BigInt(rpcBlock.gasLimit).toString(),\n        gasUsed: BigInt(rpcBlock.gasUsed).toString(),\n        miner: rpcBlock.miner,\n        extraData: rpcBlock.extraData,\n        transactions: Array.isArray(rpcBlock.transactions)\n            ? rpcBlock.transactions.map(function (tx) {\n                return typeof tx === "string" ? tx : tx.hash;\n            })\n            : [],\n        size: rpcBlock.size,\n        logsBloom: rpcBlock.logsBloom,\n        stateRoot: rpcBlock.stateRoot,\n        receiptsRoot: rpcBlock.receiptsRoot,\n        transactionsRoot: rpcBlock.transactionsRoot,\n        uncles: rpcBlock.uncles || [],\n        mixHash: rpcBlock.mixHash || "",\n        sha3Uncles: rpcBlock.sha3Uncles,\n        totalDifficulty: rpcBlock.totalDifficulty\n            ? BigInt(rpcBlock.totalDifficulty).toString()\n            : BigInt(rpcBlock.difficulty).toString(),\n        blobGasUsed: "",\n        excessBlobGas: "",\n        withdrawalsRoot: rpcBlock.withdrawalsRoot || "",\n        withdrawals: rpcBlock.withdrawals\n            ? rpcBlock.withdrawals.map(function (w) { return ({\n                address: w.address,\n                amount: w.amount,\n                index: w.index,\n                validatorIndex: w.validatorIndex,\n            }); })\n            : [],\n    };\n}\n/**\n * Transforms an Optimism RPC transaction response into a Transaction domain object\n * Includes Optimism-specific L1 fee fields in the receipt\n */\nfunction transformOptimismTransactionToTransaction(rpcTx, receipt) {\n    var transaction = {\n        hash: rpcTx.hash,\n        from: rpcTx.from,\n        to: rpcTx.to || "",\n        value: BigInt(rpcTx.value).toString(),\n        gas: BigInt(rpcTx.gas).toString(),\n        gasPrice: rpcTx.gasPrice ? BigInt(rpcTx.gasPrice).toString() : "0",\n        maxFeePerGas: rpcTx.maxFeePerGas ? BigInt(rpcTx.maxFeePerGas).toString() : undefined,\n        maxPriorityFeePerGas: rpcTx.maxPriorityFeePerGas\n            ? BigInt(rpcTx.maxPriorityFeePerGas).toString()\n            : undefined,\n        nonce: rpcTx.nonce ? parseInt(rpcTx.nonce, 16).toString() : "0",\n        data: rpcTx.input,\n        blockNumber: rpcTx.blockNumber ? parseInt(rpcTx.blockNumber, 16).toString() : "0",\n        blockHash: rpcTx.blockHash || "",\n        transactionIndex: rpcTx.transactionIndex\n            ? parseInt(rpcTx.transactionIndex, 16).toString()\n            : "0",\n        v: rpcTx.v,\n        r: rpcTx.r,\n        s: rpcTx.s,\n        type: rpcTx.type,\n    };\n    if (receipt) {\n        var optimismReceipt = {\n            blockHash: receipt.blockHash,\n            blockNumber: parseInt(receipt.blockNumber, 16).toString(),\n            contractAddress: receipt.contractAddress,\n            cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed).toString(),\n            effectiveGasPrice: receipt.effectiveGasPrice\n                ? BigInt(receipt.effectiveGasPrice).toString()\n                : "0",\n            from: receipt.from,\n            gasUsed: BigInt(receipt.gasUsed).toString(),\n            logs: receipt.logs,\n            logsBloom: receipt.logsBloom,\n            status: receipt.status || "0x1",\n            to: receipt.to || "",\n            transactionHash: receipt.transactionHash,\n            transactionIndex: parseInt(receipt.transactionIndex, 16).toString(),\n            type: receipt.type,\n            // Optimism-specific L1 fee fields\n            l1Fee: receipt.l1Fee || "0",\n            l1GasPrice: receipt.l1GasPrice || "0",\n            l1GasUsed: receipt.l1GasUsed || "0",\n            l1FeeScalar: "1",\n        };\n        transaction.receipt = optimismReceipt;\n    }\n    return transaction;\n}\n/**\n * Creates an Address domain object from balance, code, and transaction count\n */\nfunction createAddressFromBalance(address, balance, code, txCount) {\n    return {\n        address: address,\n        balance: BigInt(balance).toString(),\n        code: code,\n        txCount: parseInt(txCount, 16).toString(),\n        storageAt: {},\n    };\n}\n/**\n * Converts a hex string to a number\n */\nfunction hexToNumber(hex) {\n    return parseInt(hex, 16);\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/OptimismAdapter/utils.ts?')},71613:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDataService: () => (/* binding */ useDataService)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ 96540);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _context_AppContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context/AppContext */ 92936);\n/* harmony import */ var _context_SettingsContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../context/SettingsContext */ 99552);\n/* harmony import */ var _services_DataService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/DataService */ 48198);\n// src/hooks/useDataService.ts\n\n\n\n\n/**\n * Hook to get a DataService for a specific network\n * Automatically applies the RPC strategy from user settings\n * @param networkId - The network ID\n * @returns DataService instance\n */\nfunction useDataService(networkId) {\n    var rpcUrls = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context_AppContext__WEBPACK_IMPORTED_MODULE_1__.AppContext).rpcUrls;\n    var settings = (0,_context_SettingsContext__WEBPACK_IMPORTED_MODULE_2__.useSettings)().settings;\n    var dataService = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n        // Apply max parallel requests limit when using parallel strategy\n        var limitedRpcUrls = rpcUrls;\n        if (settings.rpcStrategy === "parallel" &&\n            settings.maxParallelRequests &&\n            settings.maxParallelRequests > 0) {\n            // Limit the RPC URLs to the first N endpoints for each network\n            limitedRpcUrls = Object.keys(rpcUrls).reduce(function (acc, key) {\n                var chainId = Number(key);\n                var urls = rpcUrls[chainId];\n                if (urls) {\n                    acc[chainId] = urls.slice(0, settings.maxParallelRequests);\n                }\n                return acc;\n            }, {});\n        }\n        return new _services_DataService__WEBPACK_IMPORTED_MODULE_3__.DataService(networkId, limitedRpcUrls, settings.rpcStrategy);\n    }, [networkId, rpcUrls, settings.rpcStrategy, settings.maxParallelRequests]);\n    return dataService;\n}\n\n\n//# sourceURL=webpack://openscan/./src/hooks/useDataService.ts?')},72133:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeBlockNumber: () => (/* binding */ normalizeBlockNumber)\n/* harmony export */ });\n/**\n * Normalizes a block number to the format expected by RPC clients\n * Converts numeric block numbers to hex strings, passes through block tags and hex strings unchanged\n *\n * @param blockNumber - Block number as number, hex string, or block tag\n * @returns Block number as hex string or block tag\n */\nfunction normalizeBlockNumber(blockNumber) {\n    if (typeof blockNumber === "number") {\n        return "0x".concat(blockNumber.toString(16));\n    }\n    return blockNumber;\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/shared/normalizeBlockNumber.ts?')},97623:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddressFromBalance: () => (/* binding */ createAddressFromBalance),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   transformPolygonBlockToBlock: () => (/* binding */ transformPolygonBlockToBlock),\n/* harmony export */   transformPolygonTransactionToTransaction: () => (/* binding */ transformPolygonTransactionToTransaction)\n/* harmony export */ });\n/**\n * Transforms an RPC block response into a Block domain object\n * Handles hex-to-decimal conversions and normalizes fields\n */\nfunction transformPolygonBlockToBlock(rpcBlock) {\n    var timestamp = rpcBlock.timestamp\n        ? parseInt(rpcBlock.timestamp, rpcBlock.timestamp.startsWith("0x") ? 16 : 10).toString()\n        : "0";\n    return {\n        number: rpcBlock.number,\n        hash: rpcBlock.hash,\n        parentHash: rpcBlock.parentHash,\n        timestamp: timestamp,\n        baseFeePerGas: rpcBlock.baseFeePerGas ? BigInt(rpcBlock.baseFeePerGas).toString() : undefined,\n        nonce: rpcBlock.nonce,\n        difficulty: BigInt(rpcBlock.difficulty).toString(),\n        gasLimit: BigInt(rpcBlock.gasLimit).toString(),\n        gasUsed: BigInt(rpcBlock.gasUsed).toString(),\n        miner: rpcBlock.miner,\n        extraData: rpcBlock.extraData,\n        transactions: Array.isArray(rpcBlock.transactions)\n            ? rpcBlock.transactions.map(function (tx) { return (typeof tx === "string" ? tx : tx.hash); })\n            : [],\n        size: rpcBlock.size,\n        logsBloom: rpcBlock.logsBloom,\n        stateRoot: rpcBlock.stateRoot,\n        receiptsRoot: rpcBlock.receiptsRoot,\n        transactionsRoot: rpcBlock.transactionsRoot,\n        uncles: rpcBlock.uncles || [],\n        mixHash: rpcBlock.mixHash || "",\n        sha3Uncles: rpcBlock.sha3Uncles,\n        totalDifficulty: rpcBlock.totalDifficulty\n            ? BigInt(rpcBlock.totalDifficulty).toString()\n            : BigInt(rpcBlock.difficulty).toString(),\n        blobGasUsed: "",\n        excessBlobGas: "",\n        withdrawalsRoot: rpcBlock.withdrawalsRoot || "",\n        withdrawals: rpcBlock.withdrawals || [],\n    };\n}\n/**\n * Transforms an RPC transaction response into a Transaction domain object\n * Handles hex-to-decimal conversions and includes receipt if provided\n */\nfunction transformPolygonTransactionToTransaction(rpcTx, receipt) {\n    var transaction = {\n        hash: rpcTx.hash,\n        from: rpcTx.from,\n        to: rpcTx.to || "",\n        value: BigInt(rpcTx.value).toString(),\n        gas: BigInt(rpcTx.gas).toString(),\n        gasPrice: rpcTx.gasPrice ? BigInt(rpcTx.gasPrice).toString() : "0",\n        maxFeePerGas: rpcTx.maxFeePerGas ? BigInt(rpcTx.maxFeePerGas).toString() : undefined,\n        maxPriorityFeePerGas: rpcTx.maxPriorityFeePerGas\n            ? BigInt(rpcTx.maxPriorityFeePerGas).toString()\n            : undefined,\n        nonce: rpcTx.nonce ? parseInt(rpcTx.nonce, 16).toString() : "0",\n        data: rpcTx.input,\n        blockNumber: rpcTx.blockNumber ? parseInt(rpcTx.blockNumber, 16).toString() : "0",\n        blockHash: rpcTx.blockHash || "",\n        transactionIndex: rpcTx.transactionIndex\n            ? parseInt(rpcTx.transactionIndex, 16).toString()\n            : "0",\n        v: rpcTx.v,\n        r: rpcTx.r,\n        s: rpcTx.s,\n        type: rpcTx.type,\n    };\n    if (receipt) {\n        transaction.receipt = {\n            blockHash: receipt.blockHash,\n            blockNumber: parseInt(receipt.blockNumber, 16).toString(),\n            contractAddress: receipt.contractAddress,\n            cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed).toString(),\n            effectiveGasPrice: receipt.effectiveGasPrice\n                ? BigInt(receipt.effectiveGasPrice).toString()\n                : "0",\n            from: receipt.from,\n            gasUsed: BigInt(receipt.gasUsed).toString(),\n            logs: receipt.logs,\n            logsBloom: receipt.logsBloom,\n            status: receipt.status || "0x1",\n            to: receipt.to || "",\n            transactionHash: receipt.transactionHash,\n            transactionIndex: parseInt(receipt.transactionIndex, 16).toString(),\n            type: receipt.type,\n        };\n    }\n    return transaction;\n}\n/**\n * Creates an Address domain object from balance, code, and transaction count\n */\nfunction createAddressFromBalance(address, balance, code, txCount) {\n    return {\n        address: address,\n        balance: BigInt(balance).toString(),\n        code: code,\n        txCount: parseInt(txCount, 16).toString(),\n        storageAt: {},\n    };\n}\n/**\n * Converts a hex string to a number\n */\nfunction hexToNumber(hex) {\n    return parseInt(hex, 16);\n}\n\n\n//# sourceURL=webpack://openscan/./src/services/adapters/PolygonAdapter/utils.ts?')}}]);